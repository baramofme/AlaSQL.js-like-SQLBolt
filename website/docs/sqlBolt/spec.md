# LoveField Spec

## 초기화

## 다중 프로세스 접속

## 데이터베이스 업그레이드

Lovefield는 스키마에 지정된 버전을 사용하여 데이터베이스를 엽니다([스키마 정의] 참조).
버전이 일치하지 않으면 데이터베이스 업그레이드 메커니즘이 트리거됩니다.

[스키마 정의]: create-table#러브필드-스키마-정의

데이터베이스 업그레이드의 첫 번째 단계는 새 테이블을 만드는 것입니다. 러브 필드는
데이터베이스에 없지만 스키마에 있는 테이블 확인하고 확인된 테이블을 적절하게 생성합니다.
이 작업이 끝나면 Lovefield는 사용자가 제공 한 업그레이드 기능을 호출합니다.

사용자는 업그레이드가 테이블 데이터를 삭제하거나 변환하는 경우 다음의 `connect()` 같은 
매개 변수로 맞춤 업그레이드 기능을 제공해야합니다. 
함수는 테이블 스키마 변경을 수행 할 수있는 원시 데이터베이스 인스턴스를받습니다.
함수는 프로미스를 반환해야합니다. 프로미스가 해결되면 새 데이터베이스 인스턴스가 생성되고 이에 대한 연결이 새 인스턴스로 반환됩니다.
프로미스가 거부되면,`connect()` 호출 또한 거절 될 것입니다.

사용자는 새로운 색인에 대해 걱정할 필요가 없으며 버전 업그레이드에 대해서 색인을 변경할 필요가 없습니다.
쿼리 엔진은 인덱스 스키마 변경을 감지하고 필요한 경우 모든 색인을 재생성 합니다.
쿼리 엔진은 데이터베이스 업그레이 드의 시나리오에서 데이터 일관성을 보장하기 위해 
모든 영구적(persisted)인 인덱스를 삭제하고 다시 작성합니다.

테이블을 삭제하는 경우, 사용자는 업그레이드 함수에서 삭제 수행을 할 책임이 있습니다. 
Lovefield는 데이터 안전을 우려해 자동 드롭 기능을 제공하지 않습니다.
IndexedDB는 테이블의 이름을 바꾸는 방법을 제공하지 않으므로 테이블 이름을 바꾸려면 
정확한 내용물로 테이블을 다시 생성하고 오래된 테이블을 삭제해야합니다.
만약 업그레이드 트랜잭션 에서 안전하게 완료할 수 없는 것이 있다면 
사용자는 `onUpgrade` 함수 밖에서 수동으로 처리해야합니다.

테이블을 변경하는 경우, 만약 열의 이름을 바꾸고, nullable/fixed 값 열 또는 열 삭제, 추가하는 변환이라면, 
사용자는 제공된 도우미 함수를 사용할 수 있는데, 그렇지 않으면 사용자는 행 단위로 변환해야합니다. 
이름 바꾸기에 경우, 사용자는 이름이 변경된 열이 이전 테이블과 동일한 스키마이며 이름이 변경된 열은
정확히 동일한 유형을 가졌음을 확인해야 합니다.
변형의 경우, 사용자는 변환 된 행이 새로운 스키마에 적합하며 제약 조건을 위반하지 않음을 확인해야 합니다.
이렇게하지 않으면 쿼리를 실행하는 동안 예외가 throw 될 수 있습니다.
Lovefield는 열 유형을 직접 변경하는 것을 허용하지 않습니다.

다음은 데이터베이스 업그레이드를 보여주는 샘플 코드 단편입니다.

```javascript
// 데이터 베이스 열기, 필요하면 데이터 베이스 생성이나 업그레이드 수행.
schemaBuilder.connect({onUpgrade: onUpgrade}).then(
  // 모든 새/업그레이드 관련 행위가 완료됐을 때.
  /** @param {lf.Database} db */
  function(db) {
    // 새로운 db 접속이 여기서부터 시작
  });

/**
 * loveField 가 새 테이블을 생성한 이후에 호출되는 사용자 제공 업그레이드 함수
 *
 * NOTE: 함수가 데이터베이스 작업 이외 비동기 연산을받는 경우, 
 * 업그레이드 트랜잭션이 즉시 커밋되고 업그레이드 프로세스가 실패 할 가능성이 매우 높습니다.
 * IndexedDB auto-commit 함정에 고맙다(반어).
 * @param {lf.raw.BackStore} rawDb
 */
function onUpgrade(rawDb) {
  // 현재 저장된(persisted) 버전 보여주기.
  console.log(rawDb.getVersion());

  // Progress 테이블 드롭.
  // 동기 호출.
  rawDb.dropTable('Progress');

  // 모든 비동기 업그레이드 도우미 함수는 하나에서 다음 것으로 연쇄 해야만 한다.

  // Purchase 에서 agent 열 (type string) 추가. 기본값 'Smith'.
  return rawDb.addTableColumn('Purchase', 'agent', 'Smith').then(function() {
    // Photo 에서 metadata 열 삭제.
    return rawDb.dropTableColumn('Photo', 'metadata');
  }).then(function() {
    // Photo 테이블의 isLocal 열 이름을 local 로 변경.
    return rawDb.renameTableColumn('Photo', 'isLocal', 'local');
  }).then(function() {
    // IndexedDB 자동 커밋으로 인해 변환이 지원되지 않습니다.:
    // 러브 필드 (Lovefield)가 기존의 객체 저장소 스캐닝으로부터 프로미스를 되찾으려 할 때 파이어 폭스가 즉시 트랜잭션을 위탁한다. 
    // 사용자가 덤프를 수행하고 onUpgrade 루틴 외부에서 변환을 수행해야합니다.

    // 전체 DB 를 JS 객체로 쏟아붇기(DUMP)
    return rawDb.dump();
  });
}
```

사용자는 Lovefield가 모든 데이터를 즉시에서 업그레이드한다고 가정하지 않습니다. 특정
상황에 따라 Lovefield는 완전히 새로운 데이터베이스를 다시 만들고 데이터를 복사할 것을 요구할 수 있습니다.
(최후의 수단이됩니다. 예를 들어, 새롭고보다 효율적인 저장 포맷을 이식하는 것). 
데이터베이스 업그레이드가 시간 소모적이기 때문에, 
사용자는 자신의 진행 이벤트를 정의 하고 콜백 함수 내에서 호출할 책임이 있습니다.

[`lf.raw.BackStore`] 인터페이스에는 각 멤버 함수에 대한 자세한 문서가 들어 있습니다.

[`lf.raw.BackStore`]: https://github.com/google/lovefield/blob/master/lib/raw.js

## Database

## 쿼리 실행

## 데이터베이스 삭제

## 가져오기 내보내기


 
